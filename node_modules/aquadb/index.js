"use strict";

/**
 * @typedef {Object} Options The {@link AquaDB} options.
 * @property {string} [name="database"] The name of the database file.
 * @property {boolean} [autoFile=true] Whether the database file should be created if the node application is run.
 * @property {boolean} [ignoreWarns=false] Whether the warnings should be ignored.
 */

 /**
  * @callback UpdateFunc
  * @param {any} data
  * @returns {any}
  */
 
const EventEmitter = require("events").EventEmitter;
const { isValidValue } = require("./Util");

/**
 * @class
 * @description AquaDB
 * @extends EventEmitter
 */
class AquaDB extends EventEmitter {
  /**
   * @constructor
   * @param {JsonDB|YamlDB|BsonDB} adapter Database adapter to use.
   * @param {Options} options The {@link AquaDB} options.
   */
  constructor(adapter, options = {}) {
    super();

    let defaultOptions = {
      "name": "database",
      "autoFile": true,
      "ignoreWarns": false
    };

    /**
     * The {@link AquaDB} options.
     * @type {Options}
     */
    this.options = Object.assign(defaultOptions, options);

    /**
     * Database adapter to use.
     * @type {JsonDB|YamlDB|BsonDB}
     */
    this.adapter = new adapter(this.options);
  }

  /**
   * Sets data in created database.
   * @param {string} key
   * @param {any} value
   * @returns {any}
   * @example
   * db.set("x.y.z", "test"); // {"x": {"y": {"z": "test"}}}
   */
  set(key, value) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");
    if (typeof value === "undefined") throw new TypeError("\"value\" parameter must be available.");
    if (!isValidValue(value)) throw new TypeError("\"value\" parameter must be String or Number or Boolean or Object or Array.");

    let data = this.adapter.set(key, value);

    this.emit("data", {
      type: "SET",
      raw: {
        key: key,
        value: value,
      },
      data: data,
    });

    return data;
  }

  /**
   * Gets data from created database.
   * @param {string} key
   * @returns {any}
   * @example
   * db.set("x.y.z", "test");
   * db.get("x"); // {"y": {"z": "test"}}
   */
  get(key) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");

    let data = this.adapter.get(key);
    this.emit("data", {
      type: "GET",
      raw: {
        key: key,
      },
      data: data,
    });
    return data;
  }

  /**
   * Gets data from created database. Clone of {@link AquaDB#get get} funtion.
   * @param {string} key
   * @returns {any}
   */
  fetch(key) {
    let data = this.get(key);
    this.emit("data", {
      type: "FETCH",
      raw: {
        key: key,
      },
      data: data,
    });
    return data;
  }

  /**
   * Deletes data from created database.
   * @param {string} key
   * @returns {true}
   * @example
   * db.set("x.y.z", "test");
   * db.delete("x.y.z"); // true
   */
  delete(key) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");

    let data = this.adapter.delete(key);
    this.emit("data", {
      type: "DELETE",
      raw: {
        key: key,
      },
      data: data,
    });
    return data;
  }

  /**
   * Checks if data in created database.
   * @param {string} key
   * @returns {boolean}
   * @example
   * db.set("x.y.z", "test");
   * db.has("x"); // true
   */
  has(key) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");

    let data = !!this.get(key);
    this.emit("data", {
      type: "HAS",
      raw: {
        key: key,
      },
      data: data,
    });
    return data;
  }

  /**
   * Updates data in created database.
   * @param {string} key
   * @param {UpdateFunc} func
   * @returns {any}
   * @example
   * db.set("num", 5);
   * db.get("num"); // 5
   * db.update("num", (x => x + 5)); // 10
   * db.get("num"); // 10
   */
  update(key, func) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");
    if (typeof func === "undefined") throw new TypeError("\"func\" parameter must be available.");
    if (typeof func !== "function") throw new TypeError("\"func\" parameter must be Function.");

    if (this.has(key) === false && this.options.ignoreWarns === false) console.warn("This data isn't available. The data to be updated is received as \"undefined\".");

    let data = this.get(key);
    this.set(key, func(data));
    let newData = this.get(key);

    this.emit("data", {
      type: "UPDATE",
      raw: {
        key: key,
        func: func,
        runnedFunc: func(data),
      },
      data: newData,
    });

    return newData;
  }

  /**
   * Adds a value to data in created database.
   * @param {string} key
   * @param {number} value
   * @returns {number}
   * @example
   * db.set("num", 5);
   * db.add("num", 5); // 10
   * db.get("num"); // 10
   */
  add(key, value) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");
    if (typeof value === "undefined") throw new TypeError("\"value\" parameter must be available.");
    if (typeof value !== "number") throw new TypeError("\"value\" parameter must be Number.");

    if (this.has(key) === false && this.options.ignoreWarns === false) console.warn("This data isn't available. The data to be added is received as 0.");
    if (this.has(key) === false) this.set(key, 0);

    let data = this.get(key);
    this.set(key, data + value);
    data = this.get(key);

    this.emit("data", {
      type: "ADD",
      raw: {
        key: key,
        value: value,
      },
      data: data,
    });

    return data;
  }

  /**
   * Subtracts a value to data in created database.
   * @param {string} key
   * @param {number} value
   * @returns {number}
   * @example
   * db.set("num", 5);
   * db.subtract("num", 5); // 0
   * db.get("num"); // 0
   */
  subtract(key, value) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");
    if (typeof value === "undefined") throw new TypeError("\"value\" parameter must be available.");
    if (typeof value !== "number") throw new TypeError("\"value\" parameter must be Number.");

    if (this.has(key) === false && this.options.ignoreWarns === false) console.warn("This data isn't available. The data to be added is received as 0.");
    if (this.has(key) === false) this.set(key, 0);

    let data = this.get(key);
    this.set(key, data - value);
    data = this.get(key);

    this.emit("data", {
      type: "SUBTRACT",
      raw: {
        key: key,
        value: value,
      },
      data: data,
    });

    return data;
  }

  /**
   * Subtracts a value to data in created database. Clone of {@link AquaDB#subtract subtract} function.
   * @param {string} key
   * @param {number} value
   * @returns {number}
   */
  subs(key, value) {
    return this.subtract(key, value);
  }

  /**
   * Subtracts a value to data in created database. Clone of {@link AquaDB#subtract subtract} function.
   * @param {string} key
   * @param {number} value
   * @returns {number}
   */
  substract(key, value) {
    return this.subtract(key, value);
  }

  /**
   * Pushs element to data in created database.
   * @param {string} key
   * @param {...any} value
   * @returns {any[]}
   * @example
   * db.set("x.y.z", []);
   * db.push("x.y.z", "test", "hello"); // ["test", "hello"]
   * db.get("x.y.z"); // ["test", "hello"]
   */
  push(key, ...value) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");
    if (typeof value[0] === "undefined") throw new TypeError("\"value\" parameter must be available.");
    if (!isValidValue(value)) throw new TypeError("\"value\" parameter must be String or Number or Boolean or Object or Array.");

    if (this.has(key) === false && this.options.ignoreWarns === false) console.warn("This data isn't available. Created new array to this data.");
    if (this.has(key) === false) this.set(key, []);

    let data = this.get(key);

    if (!Array.isArray(data)) throw new TypeError("The data must be a array.");

    for (let val of value) {
      data.push(val);
    }

    this.set(key, data);

    this.emit("data", {
      "type": "PUSH",
      "raw": {
        "key": key,
        "value": value
      },
      "data": data
    });

    return data;
  }

  /**
   * Sets element from data in created database by index.
   * @param {string} key
   * @param {number} index
   * @param {any} value
   * @returns {any[]}
   * @example
   * db.get("x.y.z"); // ["test", "hello", "okey"]
   * db.setByIndex("x.y.z", 1, "hi"); // ["test", "hi", "okey"]
   * db.get("x.y.z"); // ["test", "hi", "okey"]
   */
  setByIndex(key, index, value) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");
    if (typeof index === "undefined") throw new TypeError("\"index\" parameter must be available.");
    if (typeof index !== "number") throw new TypeError("\"index\" parameter must be Number.");
    if (typeof value === "undefined") throw new TypeError("\"value\" parameter must be available.");
    if (!isValidValue(value)) throw new TypeError("\"value\" parameter must be String or Number or Boolean or Object or Array.");

    if (this.has(key) === false && this.options.ignoreWarns === false) console.warn("This data isn't available. Created new array to this data.");
    if (this.has(key) === false) this.set(key, []);

    let data = this.get(key);

    if (!Array.isArray(data)) throw new TypeError("The data must be a array.");

    data[index] = value;
    this.set(key, data);

    this.emit("data", {
      "type": "SET_BY_INDEX",
      "raw": {
        "key": key,
        "index": index,
        "value": value
      },
      "data": data
    });

    return data;
  }

  /**
   * Sets element from data in created database by value.
   * @param {string} key
   * @param {any} oldValue
   * @param {any} newValue
   * @returns {any[]}
   * @example
   * db.get("x.y.z"); // ["test", "hello", "okey"]
   * db.setByValue("x.y.z", "hello", "hi"); // ["test", "hi", "okey"]
   * db.get("x.y.z"); // ["test", "hi", "okey"]
   */
  setByValue(key, oldValue, newValue) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");
    if (typeof oldValue === "undefined") throw new TypeError("\"oldValue\" parameter must be available.");
    if (!isValidValue(oldValue)) throw new TypeError("\"oldValue\" parameter must be String or Number or Boolean or Object or Array.");
    if (typeof newValue === "undefined") throw new TypeError("\"newValue\" parameter must be available.");
    if (!isValidValue(newValue)) throw new TypeError("\"newValue\" parameter must be String or Number or Boolean or Object or Array.");

    if (this.has(key) === false && this.options.ignoreWarns === false) console.warn("This data isn't available. Created new array to this data.");
    if (this.has(key) === false) this.set(key, [oldValue]);

    let data = this.get(key);

    if (!Array.isArray(data)) throw new TypeError("The data must be a array.");
    if (typeof data[data.indexOf(oldValue)] === "undefined") throw new TypeError("The data you wrote to the \"oldValue\" parameter in the array was not found.");

    data[data.indexOf(oldValue)] = newValue;
    this.set(key, data);

    this.emit("data", {
      "type": "SET_BY_VALUE",
      "raw": {
        "key": key,
        "oldValue": oldValue,
        "newValue": newValue
      },
      "data": data
    });

    return data;
  }

  /**
   * Deletes element from data in created database by index.
   * @param {string} key
   * @param {number} index
   * @returns {any[]}
   * @example
   * db.get("x.y.z"); // ["test", "hello", "okey"]
   * db.deleteByIndex("x.y.z", 1); // ["test", "okey"]
   * db.get("x.y.z"); // ["test", "okey"]
   */
  deleteByIndex(key, index) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");
    if (typeof index === "undefined") throw new TypeError("\"index\" parameter must be available.");
    if (typeof index !== "number") throw new TypeError("\"index\" parameter must be Number.");

    if (this.has(key) === false && this.options.ignoreWarns === false) console.warn("This data isn't available. Created new array to this data.");
    if (this.has(key) === false) this.set(key, []);

    let data = this.get(key);

    if (!Array.isArray(data)) throw new TypeError("The data must be a array.");

    data = data.filter((val, i) => i !== index);
    this.set(key, data);

    this.emit("data", {
      "type": "DELETE_BY_INDEX",
      "raw": {
        "key": key,
        "index": index
      },
      "data": data
    });

    return data;
  }

  /**
   * Deletes element from data in created database by value.
   * @param {string} key
   * @param {any} value
   * @returns {any[]}
   * @example
   * db.get("x.y.z"); // ["test", "hello", "okey"]
   * db.deleteByValue("x.y.z", "hello"); // ["test", "okey"]
   * db.get("x.y.z"); // ["test", "okey"]
   */
  deleteByValue(key, value) {
    if (typeof key === "undefined") throw new TypeError("\"key\" parameter must be available.");
    if (typeof key !== "string") throw new TypeError("\"key\" parameter must be String.");
    if (typeof value === "undefined") throw new TypeError("\"value\" parameter must be available.");
    if (!isValidValue(value)) throw new TypeError("\"value\" parameter must be String or Number or Boolean or Object or Array.");

    if (this.has(key) === false && this.options.ignoreWarns === false) console.warn("This data isn't available. Created new array to this data.");
    if (this.has(key) === false) this.set(key, []);

    let data = this.get(key);

    if (!Array.isArray(data)) throw new TypeError("The data must be a array.");
    
    data = data.filter((val) => val !== value);
    this.set(key, data);

    this.emit("data", {
      "type": "DELETE_BY_VALUE",
      "raw": {
        "key": key,
        "value": value
      },
      "data": data
    });

    return data;
  }

  /**
   * All data in created database.
   * @returns {object}
   * @example
   * db.set("x.y.z", "test");
   * db.all(); // {"x": {"y": {"z": "test"}}}
   */
  all() {
    let data = this.adapter.all();
    this.emit("data", {
      type: "ALL",
      data: data,
    });
    return data;
  }

  /**
   * Deletes all data from the generated database.
   * @returns {true}
   * @example
   * db.set("x.y.z", "test");
   * db.deleteAll(); // true
   */
  deleteAll() {
    let data = this.adapter.deleteAll();
    this.emit("data", {
      type: "DELETE_ALL",
      data: data,
    });
    return data;
  }
}

module.exports = AquaDB;
